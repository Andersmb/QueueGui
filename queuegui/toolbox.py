import tkinter as tk
from tkinter import filedialog
from tkinter import simpledialog
import random
import numpy as np
from pathlib import Path
from datetime import datetime

from output_parsers.gaussian import GaussianOut
from output_parsers.orca import OrcaOut, OrcaHess


class ToolBox(tk.Toplevel):
    def __init__(self, parent):
        tk.Toplevel.__init__(self, parent)
        self.parent = parent
        self.master = self.parent.master
        self.name = "ToolBox"
        self.title(self.name)
        self.resizable(False, False)

        # Set background color
        self["bg"] = self.master.background_color.get()

        # Place self in grid
        self.grid_columnconfigure(0, weight=1)

        # defining variables
        self.thefile = tk.StringVar()

        # Place widgets
        self.place_widgets()

        # Set title and welcome message
        self.log_update(f"Welcome to {self.name}!")
        self.log_update(f"You are in {Path.cwd()}")

    def place_widgets(self):
        # Set background color
        self.top = tk.Frame(self, bg=self.master.background_color.get())
        self.mid = tk.Frame(self, bg=self.master.background_color.get())
        self.bot = tk.Frame(self, bg=self.master.background_color.get())

        # Set up grids
        self.top.grid(row=0, column=0, sticky="nsew")
        self.mid.grid(row=1, column=0, sticky="nsew")
        self.bot.grid(row=2, column=0, sticky="nsew")
        self.mid.grid_columnconfigure(0, weight=1)
        self.bot.grid_columnconfigure(0, weight=1)

        # Buttons
        tk.Button(self.top,
                  text="Quit",
                  bg="black",
                  fg="red",
                  command=self.destroy,
                  font=self.master.main_font).grid(row=0, column=0, pady=5, padx=5)
        tk.Button(self.top,
                  text="Clear log",
                  command=self.clear_log,
                  font=self.master.main_font).grid(row=0, column=1, pady=5, padx=5)
        tk.Button(self.bot,
                  text="Browse",
                  command=self.browse_files,
                  font=self.master.main_font).grid(row=0, column=1, padx=5, pady=5, sticky="e")
        tk.Button(self.bot,
                  text="Get Optimized Geometry",
                  command=self.get_optimized_geometry,
                  font=self.master.main_font).grid(row=1, column=0, pady=5, padx=5, sticky="ew")
        tk.Button(self.bot,
                  text="Align XYZ file with 5HZ2",
                  command=self.align_xyz_to_5hz2,
                  font=self.master.main_font).grid(row=2, column=0, pady=5, padx=5, sticky="ew")
        tk.Button(self.bot,
                  text="Get ORCA normal modes",
                  command=self.get_normalmodes_orca,
                  font=self.master.main_font).grid(row=3, column=0, pady=5, padx=5, sticky="ew")
        tk.Button(self.bot,
                  text="Apply normal mode",
                  command=self.apply_normal_mode,
                  font=self.master.main_font).grid(row=4, column=0, pady=5, padx=5, sticky="ew")
        tk.Button(self.bot,
                  text="Random displacements",
                  command=self.random_displacements,
                  font=self.master.main_font).grid(row=5, column=0, pady=5, padx=5, sticky="ew")

        # Scroll bars
        yscrollbar = tk.Scrollbar(self.mid)
        yscrollbar.grid(row=0, column=1, padx=2, pady=2, sticky="ns")

        # Text boxes
        self.log = tk.Text(self.mid, height=10, yscrollcommand=yscrollbar.set, bg="black", fg="white")
        self.log.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")
        self.log.config(font=self.parent.master.log_font)

        # Apply scroll bar after Text box is set
        yscrollbar.configure(command=self.log.yview)

        # Entry text boxes
        self.entry = tk.Entry(self.bot)
        self.entry.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

    def random_displacements(self):
        self.thefile.set(self.entry.get())
        files = self.thefile.get().split()
        scale_factor = simpledialog.askfloat(self.name, "Select scale factor for random displacements",
                                             initialvalue=0.05)

        # Loop over all selected files
        for xyz in files:
            with open(xyz) as f:
                filecontent = f.readlines()

            labels = [atom.split()[0] for atom in filecontent[2:]]
            coords = np.array([[float(el) for el in atom.split()[1:]] for atom in filecontent[2:]])

            new_coords = np.array([scale_factor * random.uniform(-1, 1) + atom for atom in coords])

            with open(xyz.replace(".xyz", "_rand.xyz"), "w") as f:
                f.write("{}\n".format(len(new_coords)))
                f.write("Generated by the Toolbox (scale factor: {})\n".format(scale_factor))
                for label, coord in zip(labels, new_coords.tolist()):
                    f.write(label + " " + " ".join(map(str, coord)) + "\n")

            self.log_update("Random displacement done (scale factor: {})".format(scale_factor))

    def log_update(self, msg):
        logmsg = "[{}] {}\n".format(str(datetime.now().time()).split(".")[0], msg)
        self.log.config(state=tk.NORMAL)
        self.log.insert(tk.END, logmsg)
        self.log.see(tk.END)

    def clear_log(self):
        self.log.config(state=tk.NORMAL)
        self.log.delete(1.0, tk.END)
        self.log_update(f"Welcome to {self.name}!")

    def browse_files(self):
        ftypes = [("All files", "*.*"),
                  ("XYZ files", "*.xyz"),
                  ("Gaussian input files", "*.com"),
                  ("Gaussian/ORCA output files", "*.out"),
                  ("ORCA input files", "*.inp")]

        self.entry.delete(0, tk.END)
        self.entry.insert(0, filedialog.askopenfilenames(initialdir=Path.cwd(), parent=self, title="Select File",
                                                         filetypes=ftypes, defaultextension="*.*"))

    def get_optimized_geometry(self):
        self.thefile.set(self.entry.get())
        gaussian, orca = False, False
        files = self.thefile.get().split()
        if len(files) > 1:
            self.log_update("Entering batch mode")

        for outputfile in files:
            # Determine the software
            gaussian, orca, mrchem = self.parent.determine_job_software(outputfile)

            # Returning if neither Gaussian or ORCA file was detected,
            if gaussian == False and orca == False:
                self.log_update("Neither Gaussian or ORCA output file type was detected. ErrorCode_xud25")
                return

            ### GETTING GAUSSIAN OPT GEOM ###
            if gaussian:
                output = GaussianOut(outputfile)
                self.log_update("Getting Gaussian optimized geometry.")
                optgeom = output.geometry_trajectory()[-1]

                with open(output.filename.split(",")[-1] + "_optimized.xyz", "w") as f:
                    f.write("{}\n".format(output.no_atoms()))
                    f.write("Generated by the ToolBox\n")
                    for atom in optgeom:
                        f.write(' '.join(atom) + "\n")
                self.log_update("File written to {}".format(output.filename.split(",")[-1] + "_optimized.xyz"))


            ### GETTING OFCA OPT GEOM ###
            elif orca:
                output = OrcaOut(outputfile)
                self.log_update("Getting ORCA optimized geometry.")
                optgeom = output.geometry_trajectory()[-1]
                with open(output.filename.replace(".out", "_optimized.xyz"), "w") as f:
                    f.write(str(output.no_atoms()) + "\n")
                    f.write("Generated by the ToolBox\n")
                    for atom in optgeom:
                        f.write(atom + "\n")
                self.log_update("File written to {}".format(output.filename.replace(".out", "_optimized.xyz")))

            elif mrchem:
                self.log_update("Not supported for MRChem jobs")

    def align_xyz_to_5hz2(self):
        """
        This method aligns the given XYZ file to the published crystal structure given in
        PDB code '5HZ2'. The method uses the X,Y,Z coordinates of the C_alpha in His508,
        and translates all atoms in the provided XYZ file such that this C_alpha atom
        fully overlaps with that in 5HZ2. This way the XYZ file can be visualized in PyMOL
        overlapped with the full protein, which is useful when analyzing whether the
        calcuation has induced bad structural orientations on the model residues.

        This method expects as input the (1-indexed) atom number in the XYZ file.
        """
        self.thefile.set(self.entry.get())
        files = self.thefile.get().split()
        if len(files) > 1:
            self.log_update("Entering batch mode")

        for xyzfile in files:

            # make sure an XYZ file is given based on the extension
            if xyzfile.split(".")[-1] != "xyz":
                self.log_update(f"Using {xyzfile}")
                self.log_update("You must select an XYZ file. ErrorCode_his262")
                continue
            jobname = xyzfile.split(".")[0]

            # Now open the xyzfile
            with open(xyzfile, "r") as infile:
                inlines = infile.readlines()

            # Remove the top two lines (number of atoms and comment line)
            coord = inlines[2:]
            no_atoms = len(coord)
            # Now split each line into strings of its elements
            coord = [line.split() for line in coord]

            # Define the XYZ coordinates of His508 Calpha from PDB ID 5HZ2 (used as reference)
            xref = float(41.023)
            yref = float(14.601)
            zref = float(56.605)

            # Now ask for the C_alpha index by opening a pop-up window with an entry field.
            atomid = simpledialog.askinteger("Input Required!",
                                f"Using {xyzfile} \n Please give the atom index of the C_alpha atom in your XYZ file:")

            # Get the XYZ coordinates of the atom in the XYZ file to be translated
            x = float(coord[atomid][1])
            y = float(coord[atomid][2])
            z = float(coord[atomid][3])

            # Now compute the XYZ translations
            xtr = x - xref
            ytr = y - yref
            ztr = z - zref

            # Now translate each coordinate by the given value
            for atom in range(no_atoms):
                coord[atom][1] = str(float(coord[atom][1]) - xtr)
                coord[atom][2] = str(float(coord[atom][2]) - ytr)
                coord[atom][3] = str(float(coord[atom][3]) - ztr)

            # Now write translated coordiates to new file
            with open(jobname + "_aligned" + ".xyz", "w") as outfile:
                outfile.write("{}\n".format(no_atoms))
                outfile.write(f"Generated by {self.name}\n")
                for el in coord:
                    outfile.write(" ".join(el) + "\n")

            self.log_update("Aligned coordinates written to {}".format(jobname + "_aligned" + ".xyz"))

    def get_normalmodes_orca(self):
        """
        Extracts the normal modes from an ORCA Hessian file (.hess), and writes them
        to a new file with name <jobname_normalmodes.molden>. It works only for
        analytical frequency jobs, since otherwise the normalmodes are scattered
        acrodd multiple Hessian files.

        TODO: Rewrite with methods from the OrcaHess class
        """

        self.thefile.set(self.entry.get())
        files = self.thefile.get().split()
        if len(files) > 1:
            self.log_update("Entering batch mode")

        for hess in files:
            # get the jobname (without extension). Assumes only one "." is used in the
            # filename
            jobname = hess.split(".")[0]
            with open(hess, "r") as infile:
                inlines = infile.readlines()

            # Initialize some variables
            no_of_freq = None
            freqs = []
            modes = []
            geom = []
            # Extract the number of frequencies and all frequencies
            for i, line in enumerate(inlines):

                # Now get the number of frequencies
                if line.startswith("$vibrational_frequencies"):
                    no_of_freq = int(inlines[i + 1])
                    for j in range(no_of_freq):
                        freqs.append(float(inlines[i + j + 2].split()[1]))

                # Now get all normal modes
                if line.startswith("$normal_modes"):
                    # index where the normal mode data starts
                    start = i + 3
                    # the number of columns containing normal modes
                    cols = len(inlines[start].split()) - 1
                    # the number of times the columns are repeated
                    rows = int(float(no_of_freq) / float(cols)) + 1
                    # the number of columns in the last "line" of normal mode data
                    rest = no_of_freq - (cols * (rows - 1))

                    # minus 1 to not include the "rest" row
                    for r in range(rows - 1):
                        # define each line where the data starts
                        # i: start of normal mode section, 3: to get to where the data
                        # starts, r*(nfreq+1): move down in r multiples of nfreq (must add
                        # one due to the extra label line inbetween each normal mode)
                        start = i + 3 + r * (no_of_freq + 1)
                        for c in range(cols):
                            for f in range(no_of_freq):
                                modes.append(float(inlines[start + f].split()[c + 1]))

                    # Now pick up the "rest" normal mode
                    # move down to the last "line" of normal mode data
                    start = i + 3 + (rows - 1) * (no_of_freq + 1)
                    for r in range(rest):
                        for f in range(no_of_freq):
                            modes.append(float(inlines[start + f].split()[r + 1]))

                    # Now split the normal mode data into their x, y, and z components, as
                    # this will make it easier to write to file
                    mode_x = modes[::3]
                    mode_y = modes[1::3]
                    mode_z = modes[2::3]

                # Now get the geometry
                if line.startswith("$atoms"):
                    no_atoms = int(inlines[i + 1])
                    start = i + 2
                    for atom in range(no_atoms):
                        for k in range(5):
                            # we do not want the "mass" column in the table, so we exclude
                            # index 1 from the loop
                            if k != 1:
                                geom.append(inlines[start + atom].split()[k])
            # Now format geom into something which is easier to write (list of lists)
            coord = [[] for i in range(no_atoms)]
            for i in range(no_atoms):
                coord[i] = geom[i * 4:i * 4 + 4]

            # Define the output name as jobname_normalmodes.molden
            output = jobname + "_normalmodes.molden"
            # Now we write all of our data to file
            with open(output, "w") as o:
                o.write("[MOLDEN FORMAT]\n")
                o.write("[N_FREQ]\n")
                o.write(f"{no_of_freq}\n")
                o.write("[FREQ]\n")

                for f in freqs:
                    o.write(str(f) + "\n")

                o.write("[NATOM]\n")
                o.write(str(no_atoms) + "\n")
                o.write("[FR-COORD]\n")

                for c in coord:
                    o.write("\t".join(c) + "\n")

                o.write("[FR-NORM-COORD]\n")

                for m in range(len(modes)):
                    if float(m) % no_of_freq == 0:
                        o.write(f"vibration {str(m / no_of_freq + 1)}\n")

                    if float(m) % 3 == 0:
                        o.write(
                            "".join(str(mode_x[m / 3]) + " " + str(mode_y[m / 3]) + " " + str(mode_z[m / 3])) + "\n")
                o.close()
            self.log_update(f"Normal modes written to {jobname}_normalmodes.molden")

    def apply_normal_mode(self):
        """
        Modifies the coordinates of  an XYZ file as defined by the specified normal modes.
        Most useful for modifying a geometry when trying to get rid of imaginary modes.

        NB. Works only with ORCA jobs and the .hess file has been saved

        The displaced vector is calculated by

        v_displaced = v_original + s * d

        where s is the scalar factor controlling the degree of displacement,
        and d is the normal mode vector defining the displacement itself.

        :return: None
        """
        self.thefile.set(self.entry.get())
        files = self.thefile.get().split()

        for f in files:
            # Ask user for the value of index and scale
            index = simpledialog.askinteger("Select normal mode", "Which normal mode do you want?")
            scale = simpledialog.askfloat("Select scale factor", "Select a scale factor")

            hess = OrcaHess(f)
            mode = hess.normal_modes()[index]
            geom = hess.geometry()
            output = hess.filename.split(".")[0] + "_displaced.xyz"

            geom_displaced = []
            labels = [atom.split()[0] for atom in geom]
            for i, atom in enumerate(geom):
                c = map(float, atom.split()[1:])
                v = map(float, mode[i].split())
                c_new = [labels[i],
                         self.parent.master.AU2ANG * (c[0] + scale * v[0]),
                         self.parent.master.AU2ANG * (c[1] + scale * v[1]),
                         self.parent.master.AU2ANG * (c[2] + scale * v[2])]

                geom_displaced.append(map(str, c_new))

            with open(output, "w") as f:
                f.write(f"{len(geom)}\n")
                f.write(f"Displaced by mode {index} in {hess.filename}\n")
                for atom in geom_displaced:
                    f.write(" ".join(atom) + "\n")

            self.log_update(f"Coordinates displaced in {output}")

