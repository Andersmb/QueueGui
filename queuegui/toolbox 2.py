import tkinter as tk
from tkinter import filedialog
from tkinter import simpledialog
import random
import numpy as np
from pathlib import Path
from datetime import datetime

from output_parsers.gaussian import GaussianOut
from output_parsers.orca import OrcaOut, OrcaHess


class ToolBox(tk.Toplevel):
    def __init__(self, parent):
        tk.Toplevel.__init__(self, parent)
        self.parent = parent
        self.master = self.parent.master
        self.name = "ToolBox"
        self.title(self.name)
        self.resizable(False, False)

        # Set background color
        self["bg"] = self.master.background_color.get()

        # Place self in grid
        self.grid_columnconfigure(0, weight=1)

        # defining variables
        self.thefile = tk.StringVar()

        # Place widgets
        self.place_widgets()

        # Set title and welcome message
        self.log_update(f"Welcome to {self.name}!")
        self.log_update(f"You are in {Path.cwd()}")

    def place_widgets(self):
        # Set background color
        self.top = tk.Frame(self, bg=self.master.background_color.get())
        self.mid = tk.Frame(self, bg=self.master.background_color.get())
        self.bot = tk.Frame(self, bg=self.master.background_color.get())

        # Set up grids
        self.top.grid(row=0, column=0, sticky="nsew")
        self.mid.grid(row=1, column=0, sticky="nsew")
        self.bot.grid(row=2, column=0, sticky="nsew")
        self.mid.grid_columnconfigure(0, weight=1)
        self.bot.grid_columnconfigure(0, weight=1)

        # Buttons
        tk.Button(self.top,
                  text="Quit",
                  bg="black",
                  fg="red",
                  command=self.destroy,
                  font=self.master.main_font).grid(row=0, column=0, pady=5, padx=5)
        tk.Button(self.top,
                  text="Clear log",
                  command=self.clear_log,
                  font=self.master.main_font).grid(row=0, column=1, pady=5, padx=5)
        tk.Button(self.bot,
                  text="Browse",
                  command=self.browse_files,
                  font=self.master.main_font).grid(row=0, column=1, padx=5, pady=5, sticky="e")
        tk.Button(self.bot,
                  text="Get Optimized Geometry",
                  command=self.get_optimized_geometry,
                  font=self.master.main_font).grid(row=1, column=0, pady=5, padx=5, sticky="ew")
        tk.Button(self.bot,
                  text="Align XYZ file with 5HZ2",
                  command=self.align_xyz_to_5hz2,
                  font=self.master.main_font).grid(row=2, column=0, pady=5, padx=5, sticky="ew")
        tk.Button(self.bot,
                  text="Get ORCA normal modes",
                  command=self.get_normalmodes_orca,
                  font=self.master.main_font).grid(row=3, column=0, pady=5, padx=5, sticky="ew")
        tk.Button(self.bot,
                  text="Apply normal mode",
                  command=self.apply_normal_mode,
                  font=self.master.main_font).grid(row=4, column=0, pady=5, padx=5, sticky="ew")
        tk.Button(self.bot,
                  text="Random displacements",
                  command=self.random_displacements,
                  font=self.master.main_font).grid(row=5, column=0, pady=5, padx=5, sticky="ew")

        # Scroll bars
        yscrollbar = tk.Scrollbar(self.mid)
        yscrollbar.grid(row=0, column=1, padx=2, pady=2, sticky="ns")

        # Text boxes
        self.log = tk.Text(self.mid, height=10, yscrollcommand=yscrollbar.set, bg="black", fg="white")
        self.log.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")
        self.log.config(font=self.parent.master.log_font)

        # Apply scroll bar after Text box is set
        yscrollbar.configure(command=self.log.yview)

        # Entry text boxes
        self.entry = tk.Entry(self.bot)
        self.entry.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

    def random_displacements(self):
        self.thefile.set(self.entry.get())
        files = self.thefile.get().split()
        scale_factor = simpledialog.askfloat(self.name, "Select scale factor for random displacements",
                                             initialvalue=0.05)

        # Loop over all selected files
        for xyz in files:
            with open(xyz) as f:
                filecontent = f.readlines()

            labels = [atom.split()[0] for atom in filecontent[2:]]
            coords = np.array([[float(el) for el in atom.split()[1:]] for atom in filecontent[2:]])

            new_coords = np.array([scale_factor * random.uniform(-1, 1) + atom for atom in coords])

            with open(xyz.replace(".xyz", "_rand.xyz"), "w") as f:
                f.write("{}\n".format(len(new_coords)))
                f.write("Generated by the Toolbox (scale factor: {})\n".format(scale_factor))
                for label, coord in zip(labels, new_coords.tolist()):
                    f.write(label + " " + " ".join(map(str, coord)) + "\n")

            self.log_update("Random displacement done (scale factor: {})".format(scale_factor))

    def log_update(self, msg):
        logmsg = "[{}] {}\n".format(str(datetime.now().time()).split(".")[0], msg)
        self.log.config(state=tk.NORMAL)
        self.log.insert(tk.END, logmsg)
        self.log.see(tk.END)

    def clear_log(self):
        self.log.config(state=tk.NORMAL)
        self.log.delete(1.0, tk.END)
        self.log_update(f"Welcome to {self.name}!")

    def browse_files(self):
        ftypes = [("All files", "*.*"),
                  ("XYZ files", "*.xyz"),
                  ("Gaussian input files", "*.com"),
                  ("Gaussian/ORCA output files", "*.out"),
                  ("ORCA input files", "*.inp")]

        self.entry.delete(0, tk.END)
        self.entry.insert(0, filedialog.askopenfilenames(initialdir=Path.cwd(), parent=self, title="Select File",
                                                         filetypes=ftypes, defaultextension="*.*"))

    def get_optimized_geometry(self):
        self.thefile.set(self.entry.get())
        gaussian, orca = False, False
        files = self.thefile.get().split()
        if len(files) > 1:
            self.log_update("Entering batch mode")

        for outputfile in files:
            # Determine the software
            gaussian, orca, mrchem = self.parent.determine_job_software(outputfile)

            # Returning if neither Gaussian or ORCA file was detected,
            if gaussian == False and orca == False:
                self.log_update("Neither Gaussian or ORCA output file type was detected. ErrorCode_xud25")
                return

            ### GETTING GAUSSIAN OPT GEOM ###
            if gaussian:
                output = GaussianOut(outputfile)
                self.log_update("Getting Gaussian optimized geometry.")
                optgeom = output.geometry_trajectory()[-1]

                with open(output.filename.split(",")[-1] + "_optimized.xyz", "w") as f:
                    f.write("{}\n".format(output.no_atoms()))
                    f.write("Generated by the ToolBox\n")
                    for atom in optgeom:
                        f.write(' '.join(atom) + "\n")
                self.log_update("File written to {}".format(output.filename.split(",")[-1] + "_optimized.xyz"))


            ### GETTING OFCA OPT GEOM ###
            elif orca:
                output = OrcaOut(outputfile)
                self.log_update("Getting ORCA optimized geometry.")
                optgeom = output.geometry_trajectory()[-1]
                with open(output.filename.replace(".out", "_optimized.xyz"), "w") as f:
                    f.write(str(output.no_atoms()) + "\n")
                    f.write("Generated by the ToolBox\n")
                    for atom in optgeom:
                        f.write(atom + "\n")
                self.log_update("File written to {}".format(output.filename.replace(".out", "_optimized.xyz")))

            elif mrchem:
                self.log_update("Not supported for MRChem jobs")

    def align_xyz_to_5hz2(self):
        """
        This method aligns the given XYZ file to the published crystal structure given in
        PDB code '5HZ2'. The method uses the X,Y,Z coordinates of the C_alpha in His508,
        and translates all atoms in the provided XYZ file such that this C_alpha atom
        fully overlaps with that in 5HZ2. This way the XYZ file can be visualized in PyMOL
        overlapped with the full protein, which is useful when analyzing whether the
        calcuation has induced bad structural orientations on the model residues.

        This method expects as input the (1-indexed) atom number in the XYZ file.
        """
        self.thefile.set(self.entry.get())
        files = self.thefile.get().split()
        if len(files) > 1:
            self.log_update("Entering batch mode")

        for xyzfile in files:

            # make sure an XYZ file is given based on the extension
            if xyzfile.split(".")[-1] != "xyz":
                self.log_update(f"Using {xyzfile}")
                self.log_update("You must select an XYZ file. ErrorCode_his262")
                continue
            jobname = xyzfile.split(".")[0]

            # Now open the xyzfile
            with open(xyzfile, "r") as infile:
                inlines = infile.readlines()

            # Remove the top two lines (number of atoms and comment line)
            coord = inlines[2:]
            no_atoms = len(coord)
            # Now split each line into strings of its elements
            coord = [line.split() for line in coord]

            # Define the XYZ coordinates of His508 Calpha from PDB ID 5HZ2 (used as reference)
            xref = float(41.023)
            yref = float(14.601)
            zref = float(56.605)

            # Now ask for the C_alpha index by opening a pop-up window with an entry field.
            atomid = simpledialog.askinteger("Input Required!",
                                f"Using {xyzfile} \n Please give the atom index of the C_alpha atom in your XYZ file:")

            # Get the XYZ coordinates of the atom in the XYZ file to be translated
            x = float(coord[atomid][1])
            y = float(coord[atomid][2])
            z = float(coord[atomid][3])

            # Now compute the XYZ translations
            xtr = x - xref
            ytr = y - yref
            ztr = z - zref

            # Now translate each coordinate by the given value
            for atom in range(no_atoms):
                coord[atom][1] = str(float(coord[atom][1]) - xtr)
                coord[atom][2] = str(float(coord[atom][2]) - ytr)
                coord[atom][3] = str(float(coord[atom][3]) - ztr)

            # Now write translated coordiates to new file
            with open(jobname + "_aligned" + ".xyz", "w") as outfile:
                outfile.write("{}\n".format(no_atoms))
                outfile.write(f"Generated by {self.name}\n")
                for el in coord:
                    outfile.write(" ".join(el) + "\n")

            self.log_update("Aligned coordinates written to {}".format(jobname + "_aligned" + ".xyz"))

    def get_normalmodes_orca(self):
        """

        :return:
        """
        self.thefile.set(self.entry.get())
        files = self.thefile.get().split()

        for f in files:
            hess = OrcaHess(f)

            with open(hess.filename.replace(".hess", "_normalmodes.molden"), "w") as f:
                f.write("[MOLDEN FORMAT]\n")
                f.write("[N_FREQ]\n")
                f.write(f"{hess.no_freq()}\n")
                f.write("[FREQ]\n")

                for freq in hess.frequencies():
                    f.write(str(freq) + "\n")

                f.write("[NATOM]\n")
                f.write(str(hess.no_atoms()) + "\n")
                f.write("[FR-COORD]\n")

                for atom in hess.geometry():
                    f.write(atom + "\n")

                f.write("[FR-NORM-COORD]\n")

                for idx, mode in enumerate(hess.normal_modes()):
                    f.write(f"vibration {idx+1}\n")
                    for atom in mode:
                        f.write(' '.join(map(str, atom)) + "\n")
            self.log_update(f"Extracted normal modes to {hess.filename.replace('.hess', '_normalmodes.molden')}")

    def apply_normal_mode(self):
        """
        Modifies the coordinates of  an XYZ file as defined by the specified normal modes.
        Most useful for modifying a geometry when trying to get rid of imaginary modes.

        NB. Works only with ORCA jobs and the .hess file has been saved

        The displaced vector is calculated by

        v_displaced = v_original + s * d

        where s is the scalar factor controlling the degree of displacement,
        and d is the normal mode vector defining the displacement itself.

        :return: None
        """
        self.thefile.set(self.entry.get())
        files = self.thefile.get().split()

        for f in files:
            hess = OrcaHess(f)
            geom = hess.geometry()
            output = hess.filename.split(".")[0] + "_displaced.xyz"

            # Open message box for displaying frequencies
            show_freq = DisplayFrequencies(self, f)

            # Ask user for the value of index and scale
            index = simpledialog.askinteger("Select normal mode", "Which normal mode do you want?",
                                            initialvalue=6)

            # Destroy message box
            show_freq.destroy()

            scale = simpledialog.askfloat("Select scale factor", "Select a scale factor",
                                          initialvalue=0.05)
            mode = hess.normal_modes()[index]

            geom_displaced = []
            labels = [atom.split()[0] for atom in geom]
            for i, atom in enumerate(geom):
                c = [float(el) for el in atom.split()[1:]]
                v = mode[i]

                c_new = [labels[i],
                         f"{self.parent.master.AU2ANG * (c[0] + scale * v[0]):.6f}",
                         f"{self.parent.master.AU2ANG * (c[1] + scale * v[1]):.6f}",
                         f"{self.parent.master.AU2ANG * (c[2] + scale * v[2]):.6f}"]

                geom_displaced.append(c_new)

            with open(output, "w") as f:
                f.write(f"{len(geom)}\n")
                f.write(f"Displaced by mode {index} in {hess.filename}\n")
                for atom in geom_displaced:
                    f.write(" ".join(atom) + "\n")

            self.log_update(f"Coordinates displaced in {output}")


class DisplayFrequencies(tk.Toplevel):
    def __init__(self, parent, hessfile):
        tk.Toplevel.__init__(self, parent)
        self.parent = parent
        self.frequencies = OrcaHess(hessfile).frequencies()
        self.indeces = [i for i in range(len(self.frequencies))]
        self.frequencies.insert(0, "Frequency")
        self.indeces.insert(0, "Index")
        self.title("Vibrational Frequencies")

        self.left = tk.Frame(self)
        self.right = tk.Frame(self)
        self.left.grid(row=0, column=0)
        self.right.grid(row=0, column=1)
        self.bottom = tk.Frame(self)
        self.bottom.grid(row=1, column=0)

        indeces = "\n".join(map(str, self.indeces))
        freqs = "\n".join(map(str, self.frequencies))

        tk.Label(self.left, text=indeces).grid(row=0, column=0)
        tk.Label(self.right, text=freqs).grid(row=0, column=1)